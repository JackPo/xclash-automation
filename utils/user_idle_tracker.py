"""
User idle tracker that excludes daemon's own actions.

The problem: Windows GetLastInputInfo() tracks ALL input, including clicks
generated by the daemon's ADB automation. BlueStacks translates ADB clicks
into Windows mouse events, so the daemon's own clicks reset the idle timer.

Solution: Simple system-wide idle tracking that filters daemon actions.
- If system_idle < 1 second AND daemon didn't just click â†’ user is active
- When daemon is about to click, it calls mark_daemon_action()
- Any system idle resets in the next 5 seconds are ignored (daemon caused them)
"""
import ctypes
import time


class LASTINPUTINFO(ctypes.Structure):
    _fields_ = [("cbSize", ctypes.c_uint), ("dwTime", ctypes.c_ulong)]


def _get_system_idle_seconds() -> float:
    """Get raw system idle time from Windows API."""
    lii = LASTINPUTINFO()
    lii.cbSize = ctypes.sizeof(LASTINPUTINFO)
    ctypes.windll.user32.GetLastInputInfo(ctypes.byref(lii))
    millis = ctypes.windll.kernel32.GetTickCount() - lii.dwTime
    return millis / 1000.0


class UserIdleTracker:
    """
    Track user idle time, excluding daemon's own clicks.

    Simple system-wide idle tracking:
    - Tracks ALL input anywhere on the computer
    - Filters out daemon's own ADB clicks (which get translated to mouse events)

    Call mark_daemon_action() before every ADB click.
    Use get_user_idle_seconds() to check idle.
    """

    # How long after a daemon click to ignore system idle resets
    DAEMON_CLICK_GRACE_PERIOD = 5.0  # seconds

    # If system_idle is below this, user JUST provided input
    ACTIVE_INPUT_THRESHOLD = 1.0  # seconds

    def __init__(self):
        self._last_user_activity = time.time()
        self._last_daemon_action = 0.0  # Never clicked yet
        self._prev_system_idle = 0.0

    def mark_daemon_action(self):
        """
        Call BEFORE the daemon performs a click/action.

        This marks the current time so that any system idle resets
        within the next DAEMON_CLICK_GRACE_PERIOD seconds are ignored.
        """
        self._last_daemon_action = time.time()

    def update(self):
        """
        Update user idle tracking based on system input.

        Call this every daemon iteration BEFORE checking idle.

        Simple logic: If system idle is low (user just did input ANYWHERE)
        AND daemon didn't just click, then user is active.
        """
        system_idle = _get_system_idle_seconds()
        time_since_daemon_action = time.time() - self._last_daemon_action
        daemon_acted_recently = time_since_daemon_action < self.DAEMON_CLICK_GRACE_PERIOD

        # Simple: if system_idle is low AND daemon didn't cause it, user is active
        if system_idle < self.ACTIVE_INPUT_THRESHOLD and not daemon_acted_recently:
            self._last_user_activity = time.time()

        self._prev_system_idle = system_idle

    def get_user_idle_seconds(self) -> float:
        """
        Get true user idle time (excludes daemon actions).

        Returns:
            Seconds since last REAL user activity.
        """
        return time.time() - self._last_user_activity

    def get_system_idle_seconds(self) -> float:
        """
        Get raw system idle time (for logging/comparison).

        Returns:
            Seconds since ANY system input (including daemon clicks).
        """
        return _get_system_idle_seconds()


# Singleton instance
_tracker = None


def get_user_idle_tracker() -> UserIdleTracker:
    """Get the singleton UserIdleTracker instance."""
    global _tracker
    if _tracker is None:
        _tracker = UserIdleTracker()
    return _tracker


def mark_daemon_action():
    """Convenience function: mark that daemon is about to click."""
    get_user_idle_tracker().mark_daemon_action()


def get_user_idle_seconds() -> float:
    """
    Convenience function: get user idle time (excluding daemon actions).

    Also updates the tracker, so it's safe to call this
    without explicitly calling update() first.
    """
    tracker = get_user_idle_tracker()
    tracker.update()
    return tracker.get_user_idle_seconds()


def format_user_idle_time(seconds: float) -> str:
    """Format idle time as human-readable string (e.g., '2m 30s')."""
    if seconds < 60:
        return f"{int(seconds)}s"
    elif seconds < 3600:
        mins = int(seconds // 60)
        secs = int(seconds % 60)
        return f"{mins}m {secs}s"
    else:
        hours = int(seconds // 3600)
        mins = int((seconds % 3600) // 60)
        return f"{hours}h {mins}m"


if __name__ == "__main__":
    # Test the tracker
    print("User Idle Tracker Test")
    print("=" * 40)
    print("This simulates daemon behavior:")
    print("- Every 3 seconds, daemon 'clicks' (marks action)")
    print("- User idle should accumulate despite daemon clicks")
    print("- Touch keyboard/mouse to reset user idle")
    print("Press Ctrl+C to exit")
    print()

    tracker = get_user_idle_tracker()

    try:
        iteration = 0
        while True:
            iteration += 1

            # Simulate daemon action every 3 seconds
            if iteration % 6 == 0:  # Every 3 seconds (0.5s sleep)
                print(f"[{iteration}] DAEMON CLICK (marking action)")
                tracker.mark_daemon_action()

            tracker.update()
            user_idle = tracker.get_user_idle_seconds()
            sys_idle = tracker.get_system_idle_seconds()

            print(
                f"[{iteration}] user_idle: {format_user_idle_time(user_idle)}, "
                f"sys_idle: {format_user_idle_time(sys_idle)}",
                end="\r"
            )
            time.sleep(0.5)
    except KeyboardInterrupt:
        print("\nDone.")
